<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Scope</title>
    <link rel="stylesheet" href="../style/markdown.css">
    <link href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/dracula.min.css" rel="stylesheet">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
</head>
<body>
    <h1 id="chapter1-">Chapter1. 作用域</h1>
<h2 id="-">编译原理</h2>
<p>“编译”过程:</p>
<ol>
<li>分词。将语句分为有意义的令牌（token）。例如<code>var a = 2;</code>被分隔分为<code>var</code>、<code>a</code>、<code>=</code>、<code>2</code>、<code>;</code>。</li>
<li>解析。将所有令牌解析为代表程序语法结构的树，抽象语法树（AST）。</li>
<li>生成代码。将AST解析为可执行代码。</li>
</ol>
<p>其他语言的编译过程发生在代码执行前，而Javascript的编译过程<strong>就发生在</strong>执行那一行代码的之前，简单点说就是编译一行，执行一行。（这里的一行是为了方便理解，并不一定就是一行语句）</p>
<h2 id="-">作用域</h2>
<p>演员表：</p>
<ol>
<li>引擎。</li>
<li>编译器。</li>
<li>作用域。收集并维护所有可以查讯到的变量。</li>
</ol>
<pre><code class="lang-javascript">var a = 2;
var b = a;
</code></pre>
<p>对于第一行代码，引擎会将其视为两条语句：<code>var a</code>、<code>a = 2</code>;</p>
<ol>
<li><code>var a</code>，声明一个变量并存储在作用域（在此之前编译器先查询<code>a</code>存在）</li>
<li><code>a = 2</code>，对<code>a</code>进行赋值操作</li>
</ol>
<p>对于第二行代码，引擎会先对<code>b</code>进行左查询，然后对<code>a</code>进行右查询：</p>
<ol>
<li>左查询，LHS，查找这个变量并对其赋值。失败的话会隐式创建全局变量（非严格模式）；抛出<code>ReferenceError</code>（严格模式）</li>
<li>右查询，RHS，查找这个变量的值。失败会抛出<code>ReferenceError</code></li>
</ol>
<h4 id="-">小测试</h4>
<p>下面代码中LHS和RHS各有多少次？</p>
<pre><code class="lang-javascript">function foo(a) {
    var b = a;
    return a + b;
}

var c = foo( 2 );
</code></pre>
<h2 id="-">作用域链</h2>
<p>最顶层的作用域叫全局作用域（浏览器环境下的<code>window</code>对象），因为函数可以内嵌，因此函数的作用域也可以进行嵌套。</p>
<p>引擎向作用域进行变量查询的时候，会从最近（最底层）的作用域开始查询，如果没有则继续向上查询，如果在最顶层的全局作用域依然查询不到，就抛出异常。这也就是常说的作用域链。</p>
<p>以下面这段代码为例。其作用域链为：<code>window(foo) -&gt; foo(a, bar) -&gt; bar(b, baz) -&gt; baz(c)</code>，括号内为对应作用域下的变量。</p>
<pre><code class="lang-javascript">function foo(a) {
    function bar(b) {
        function baz(c) {
            return a + b + c;
        }
        return baz(3);
    }
    return bar(2);
}
foo(1); // &quot;6&quot;
</code></pre>
<p><strong>注意</strong>：函数作用域是在这个函数创建时进行创建的，其作用域链保存在函数的内部<code>[[Scopes]]</code>属性中，可以看作是一个数组，第一项是父级作用域，最后一项则是全局作用域。</p>
<h2 id="-">词法作用域</h2>
<p>Javascript使用的是词法作用域，即查找作用域链上的变量跟函数定义的位置有关，与函数执行的方式、顺序无关。</p>
<p>如在下面的代码中，<code>console.log(a)</code>首先会沿着作用域链向上查找<code>a</code>，即全局作用域，因此打印的是<code>1</code>，并不是函数运行时<code>bar</code>作用域下的<code>2</code>。</p>
<pre><code class="lang-javascript">var a = 1;
function foo() {
    console.log(a)
}
function bar() {
    var a = 2;
    foo();
}
bar(); // &quot;1&quot;
</code></pre>
<p><strong>注意</strong>：想想函数的作用域是在什么时候生成的？在函数声明（创建）时，因此在作用域链上查找变量时与运行顺序无关。</p>
<h4 id="-">欺骗词法作用域</h4>
<h5 id="1-eval-">1. <code>eval()</code></h5>
<p>相当于在该语句的位置上插入传入的JS语句字符串，如果字符串中包含改变了作用域链的语句，即在运行过程中改变了作用域。
严格模式下无效。</p>
<h5 id="2-with-">2. <code>with</code></h5>
<p>缩短了代码块中变量的查询路径，即在作用域链的最后添加一个新的作用域。</p>
<p><strong>注意</strong>：尽量避免使用<code>eval()</code>和<code>with</code>：</p>
<ol>
<li>影响JS运行性能。引擎会在执行JS语句前进行优化来提高运行效率，但是这种改变作用域的行为会导致优化失败。</li>
<li>受严格模式影响。</li>
</ol>

    <script >hljs.initHighlightingOnLoad();</script>
</body>
</html>
