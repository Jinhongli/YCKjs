# Chapter 1. 作用域

## 编译原理

“编译”过程:
1. 分词。将语句分为有意义的令牌（token）。例如`var a = 2;`被分隔分为`var`、`a`、`=`、`2`、`;`。
2. 解析。将所有令牌解析为代表程序语法结构的树，抽象语法树（AST）。
3. 生成代码。将AST解析为可执行代码。

其他语言的编译过程发生在代码执行前，而Javascript的编译过程**就发生在**执行那一行代码的之前，简单点说就是编译一行，执行一行。（这里的一行是为了方便理解，并不一定就是一行语句）

## 作用域

演员表：
1. 引擎。
2. 编译器。
3. 作用域。收集并维护所有可以查讯到的变量。

```javascript
var a = 2;
var b = a;
```

对于第一行代码，引擎会将其视为两条语句：`var a`、`a = 2`;
1. `var a`，声明一个变量并存储在作用域（在此之前编译器先查询`a`存在）
2. `a = 2`，对`a`进行赋值操作

对于第二行代码，引擎会先对`b`进行左查询，然后对`a`进行右查询：
1. 左查询，LHS，查找这个变量并对其赋值。失败的话会隐式创建全局变量（非严格模式）；抛出`ReferenceError`（严格模式）
2. 右查询，RHS，查找这个变量的值。失败会抛出`ReferenceError`

#### 小测试

下面代码中LHS和RHS各有多少次？

```javascript
function foo(a) {
    var b = a;
    return a + b;
}
var c = foo( 2 );
```

## 作用域链

最顶层的作用域叫全局作用域（浏览器环境下的`window`对象），因为函数可以内嵌，因此函数的作用域也可以进行嵌套。

引擎向作用域进行变量查询的时候，会从最近（最底层）的作用域开始查询，如果没有则继续向上查询，如果在最顶层的全局作用域依然查询不到，就抛出异常。这也就是常说的作用域链。

以下面这段代码为例。其作用域链为：`window(foo) -> foo(a, bar) -> bar(b, baz) -> baz(c)`，括号内为对应作用域下的变量。

```javascript
function foo(a) {
    function bar(b) {
        function baz(c) {
            return a + b + c;
        }
        return baz(3);
    }
    return bar(2);
}
foo(1); // "6"
```

**注意**：函数作用域是在这个函数创建时进行创建的，其作用域链保存在函数的内部`[[Scopes]]`属性中，可以看作是一个数组，第一项是父级作用域，最后一项则是全局作用域。

## 词法作用域

Javascript使用的是词法作用域，即查找作用域链上的变量跟函数定义的位置有关，与函数执行的方式、顺序无关。

如在下面的代码中，`console.log(a)`首先会沿着作用域链向上查找`a`，即全局作用域，因此打印的是`1`，并不是函数运行时`bar`作用域下的`2`。

```javascript
var a = 1;
function foo() {
    console.log(a)
}
function bar() {
    var a = 2;
    foo();
}
bar(); // "1"
```

**注意**：想想函数的作用域是在什么时候生成的？在函数声明（创建）时，因此在作用域链上查找变量时与运行顺序无关。

#### 欺骗词法作用域

##### 1. `eval()`

相当于在该语句的位置上插入传入的JS语句字符串，如果字符串中包含改变了作用域链的语句，即在运行过程中改变了作用域。
严格模式下无效。

##### 2. `with`

缩短了代码块中变量的查询路径，即在作用域链的最后添加一个新的作用域。

**注意**：尽量避免使用`eval()`和`with`：
1. 影响JS运行性能。引擎会在执行JS语句前进行优化来提高运行效率，但是这种改变作用域的行为会导致优化失败。
2. 受严格模式影响。
